# Component-API Syntax: Line-by-Line Explanation

This document provides a line-by-line explanation of how the likes functionality works, following the code flow from component to API and back.

## Function Prefix Conventions

Our codebase follows consistent naming conventions for functions that make their purpose immediately clear:

| Prefix | Purpose | Example | Description |
|--------|---------|---------|-------------|
| **`use`** | React hooks | `useAuth()` | Functions that start with "use" are React hooks. They follow React's rules of hooks (only call at top level, only call from React functions). Hooks can manage state, handle side effects, or encapsulate reusable logic. |
| **`handle`** | Event handlers | `handleLikeToggle()` | Functions that respond to user interactions like clicks, form submissions, or input changes. They typically process the event and update state or trigger other actions. |
| **`fetch`** | Data retrieval | `fetchPost()` | Functions that retrieve data from APIs. They typically return promises and are often used with async/await. |
| **`create`** | Resource creation | `createLike()` | Functions that create new resources, usually through API calls. They handle the creation process and often return the newly created resource. |
| **`update`** | Resource modification | `updatePost()` | Functions that modify existing resources, usually through API calls. They handle the update process and often return the updated resource. |
| **`delete`** | Resource removal | `deleteLike()` | Functions that remove resources, usually through API calls. They handle the deletion process and often return a success indicator. |
| **`get`** | Simple retrieval | `getAuthHeaders()` | Utility functions that retrieve or compute values without side effects. Unlike fetch functions, they typically work with local data rather than making API calls. |
| **`set`** | State updaters | `setLiked()` | Functions generated by React's useState hook that update a specific piece of state. They follow the pattern `set[StateName]`. |
| **`is`** | Boolean state | `isLoading` | State variables that represent boolean conditions. They follow the pattern `is[Condition]`. |
| **`on`** | Callback props | `onLikeChange` | Props that are callback functions passed from parent to child components. They follow the pattern `on[Event]`. |

These naming conventions help maintain consistency across the codebase and make it easier to understand what each function does at a glance.

## Frontend Flow

### 1. Heart Icon Component
**File: `client/src/components/icons/HeartIcon.tsx`**

```typescript
// Define the props interface for the HeartIcon component
interface HeartIconProps {
  filled?: boolean    // Whether the heart should be filled (liked) or outlined (not liked)
  className?: string  // CSS classes for styling
}

// Component definition with default prop values
export function HeartIcon({ filled = false, className = "" }: HeartIconProps) {
  // Conditional rendering based on the filled prop
  return filled ? (
    // Filled heart SVG - shown when content is liked
    <svg 
      xmlns="http://www.w3.org/2000/svg" 
      viewBox="0 0 24 24" 
      fill="currentColor"  // Uses the text color of the parent element
      className={className}
    >
      <path d="M11.645 20.91l-.007-.003-.022-.012a15.247 15.247 0 01-.383-.218 25.18 25.18 0 01-4.244-3.17C4.688 15.36 2.25 12.174 2.25 8.25 2.25 5.322 4.714 3 7.688 3A5.5 5.5 0 0112 5.052 5.5 5.5 0 0116.313 3c2.973 0 5.437 2.322 5.437 5.25 0 3.925-2.438 7.111-4.739 9.256a25.175 25.175 0 01-4.244 3.17 15.247 15.247 0 01-.383.219l-.022.012-.007.004-.003.001a.752.752 0 01-.704 0l-.003-.001z" />
    </svg>
  ) : (
    // Outline heart SVG - shown when content is not liked
    <svg 
      xmlns="http://www.w3.org/2000/svg" 
      fill="none" 
      viewBox="0 0 24 24" 
      strokeWidth={1.5} 
      stroke="currentColor"  // Uses the text color of the parent element
      className={className}
    >
      <path strokeLinecap="round" strokeLinejoin="round" d="M21 8.25c0-2.485-2.099-4.5-4.688-4.5-1.935 0-3.597 1.126-4.312 2.733-.715-1.607-2.377-2.733-4.313-2.733C5.1 3.75 3 5.765 3 8.25c0 7.22 9 12 9 12s9-4.78 9-12z" />
    </svg>
  )
}
```

### 2. Like Button Component
**File: `client/src/components/buttons/LikeButton.tsx`**

```typescript
import { useState } from "react"  // React hook for local state management
import { HeartIcon } from "@/components/icons/HeartIcon"  // Import the heart icon component
import { likeEntity, unlikeEntity } from "@/api/likes"  // Import API functions for like operations

// Define the props interface for the LikeButton component
interface LikeButtonProps {
  entityType: string  // Type of content being liked (post, article, project, etc.)
  entityId: string    // Unique identifier for the content
  initialLikeCount: number  // Starting count of likes
  initialLiked: boolean     // Whether the current user has already liked this content
  size?: "sm" | "md" | "lg"  // Optional size variant
  variant?: "card" | "page"  // Optional display variant (for different contexts)
  className?: string         // Additional CSS classes
  onLikeChange?: (liked: boolean) => void  // Optional callback for parent components
}

// Component definition with default prop values
export default function LikeButton({
    entityType,
    entityId,
    initialLikeCount,
    initialLiked,
    size = "md",
    variant = "card",
    className = "",
    onLikeChange
  }: LikeButtonProps) {
    // Local state management
    const [liked, setLiked] = useState(initialLiked)  // Track liked status
    const [likeCount, setLikeCount] = useState(initialLikeCount)  // Track like count
    const [isLoading, setIsLoading] = useState(false)  // Track loading state during API calls
  
    // Handler function for like/unlike button click
    const handleLikeToggle = async () => {
      if (isLoading) return  // Prevent multiple clicks during API call
      
      setIsLoading(true)  // Set loading state to prevent additional clicks
      
      // Optimistic update - update UI immediately before API call completes
      setLiked(!liked)  // Toggle liked state
      setLikeCount(prev => !liked ? prev + 1 : Math.max(0, prev - 1))  // Update count
      
      try {
        // Make the appropriate API call based on current state
        if (liked) {
          // If currently liked, unlike it
          await unlikeEntity(entityType, entityId)  // Call API function from likes.ts
        } else {
          // If not currently liked, like it
          await likeEntity(entityType, entityId)  // Call API function from likes.ts
        }
        
        // Notify parent component if callback provided
        if (onLikeChange) {
          onLikeChange(!liked)  // Pass the new liked state to parent
        }
      } catch (error) {
        console.error('Error toggling like:', error)
        // Revert optimistic update if there's an error
        setLiked(liked)  // Revert to original liked state
        setLikeCount(prev => liked ? prev + 1 : Math.max(0, prev - 1))  // Revert count
      } finally {
        setIsLoading(false)  // Reset loading state regardless of success/failure
      }
    }
  
    // Determine size-based classes for consistent styling
    const sizeClasses = {
      sm: "text-xs",
      md: "text-sm",
      lg: "text-base"
    }[size]
  
    // Determine variant-based classes for different contexts
    const variantClasses = {
      card: "gap-1",  // Less spacing for card view
      page: "gap-2"   // More spacing for page view
    }[variant]
  
    // Render the button with appropriate styling and behavior
    return (
      <button
        onClick={handleLikeToggle}  // Attach click handler
        disabled={isLoading}        // Disable during API calls
        className={`flex items-center ${sizeClasses} ${variantClasses} ${
          liked ? 'text-red-500' : 'text-gray-500 hover:text-red-400'
        } transition-colors ${className}`}  // Dynamic classes based on state
        aria-label={liked ? "Unlike" : "Like"}  // Accessibility label
        title={liked ? "Unlike" : "Like"}       // Tooltip text
      >
        <HeartIcon 
          filled={liked}  // Pass liked state to heart icon
          className={size === "lg" ? "w-5 h-5" : "w-4 h-4"}  // Size based on prop
        />
        <span>{likeCount}</span>  // Display the like count
      </button>
  )
}
```

### 3. API Service
**File: `client/src/api/likes.ts`**

```typescript
import axios from 'axios'  // HTTP client for making API requests
import { getAuthHeaders } from '@/utils/auth'  // Helper to get authentication headers

// API base URL from environment variables or default
const API_URL = import.meta.env.VITE_API_URL || 'http://localhost:4100/api'

/**
 * Add a like to an entity
 */
export const likeEntity = async (entityType: string, entityId: string) => {
  try {
    // Make POST request to backend API
    const response = await axios.post(`${API_URL}/likes`, {
      entity_type: entityType,  // Send entity type to backend
      entity_id: entityId       // Send entity ID to backend
    }, {
      headers: getAuthHeaders()  // Include auth token in request headers
    })
    return response.data  // Return the response data to the component
  } catch (error) {
    console.error(`Error liking ${entityType}:`, error)  // Log error for debugging
    throw error  // Re-throw to allow component to handle the error
  }
}

/**
 * Remove a like from an entity
 */
export const unlikeEntity = async (entityType: string, entityId: string) => {
  try {
    // Make DELETE request to backend API
    const response = await axios.delete(`${API_URL}/likes`, {
      data: {  // For DELETE requests, data goes in the 'data' property
        entity_type: entityType,
        entity_id: entityId
      },
      headers: getAuthHeaders()  // Include auth token in request headers
    })
    return response.data  // Return the response data to the component
  } catch (error) {
    console.error(`Error unliking ${entityType}:`, error)  // Log error for debugging
    throw error  // Re-throw to allow component to handle the error
  }
}

/**
 * Check if the current user has liked an entity
 */
export const checkLikeStatus = async (entityType: string, entityId: string) => {
  try {
    // Make GET request to backend API
    const response = await axios.get(
      `${API_URL}/likes/status?entity_type=${entityType}&entity_id=${entityId}`,
      { headers: getAuthHeaders() }  // Include auth token in request headers
    )
    return response.data.liked  // Return just the liked boolean value
  } catch (error) {
    console.error(`Error checking like status for ${entityType}:`, error)
    return false  // Default to not liked if there's an error
  }
}

/**
 * Get the like count for an entity
 */
export const getLikeCount = async (entityType: string, entityId: string) => {
  try {
    // Make GET request to backend API (no auth required for this endpoint)
    const response = await axios.get(
      `${API_URL}/likes/count?entity_type=${entityType}&entity_id=${entityId}`
    )
    return response.data.count  // Return just the count number
  } catch (error) {
    console.error(`Error getting like count for ${entityType}:`, error)
    return 0  // Default to 0 if there's an error
  }
}
```

### 4. Batch Hooks
**File: `client/src/hooks/batchHooks.ts`**

```typescript
import { useState, useEffect } from 'react'  // React hooks for state and side effects
import { checkLikeStatus } from '@/api/likes'  // Import API function for checking like status
import { useAuth } from '@/hooks/useAuth'  // Custom hook for authentication state

/**
 * Hook to check like status for multiple entities at once
 * Used in list views to efficiently fetch like status for many items
 */
export function useBatchLikeStatus(items: any[], entityType: string) {
  // State to store like status for each item by ID
  const [likeStatuses, setLikeStatuses] = useState<Record<string, boolean>>({})
  const [loading, setLoading] = useState(true)  // Track loading state
  const { isAuthenticated } = useAuth()  // Get authentication status
  
  // Effect runs when items, entityType, or auth status changes
  useEffect(() => {
    // Reset statuses when items change
    setLikeStatuses({})
    
    // Skip API calls if user is not authenticated or no items
    if (!isAuthenticated || !items.length) {
      setLoading(false)
      return
    }
    
    setLoading(true)
    
    // Create an array of promises, one for each item
    const promises = items.map(item => 
      checkLikeStatus(entityType, item.id)  // Call API for each item
        .then(liked => ({ id: item.id, liked }))  // Transform response to include item ID
    )
    
    // Wait for all promises to resolve
    Promise.all(promises)
      .then(results => {
        // Convert array of results to a lookup object by ID
        const newStatuses: Record<string, boolean> = {}
        results.forEach(result => {
          newStatuses[result.id] = result.liked  // e.g., { "123": true, "456": false }
        })
        setLikeStatuses(newStatuses)  // Update state with all statuses
        setLoading(false)  // Set loading to false
      })
      .catch(error => {
        console.error('Error checking batch like status:', error)
        setLoading(false)  // Ensure loading is set to false even on error
      })
  }, [items, entityType, isAuthenticated])  // Re-run when these dependencies change
  
  // Return both the statuses object and loading state
  return { likeStatuses, loading }
}

// Additional batch hooks can be added here in the future
// e.g., useBatchFollowStatus, useBatchWatchStatus, etc.
```

## Communication Flow

1. **Parent Component to LikeButton**:
   - Parent component (e.g., PostPage) fetches content data
   - It passes entityType, entityId, initialLikeCount, and initialLiked to LikeButton

2. **User Interaction**:
   - User clicks the LikeButton
   - handleLikeToggle function is called
   - Component performs optimistic update (changes UI immediately)

3. **Component to API**:
   - LikeButton calls likeEntity or unlikeEntity from the API service
   - API service makes HTTP request to backend with entity information
   - Authentication headers are automatically included

4. **API Response Handling**:
   - If API call succeeds, the optimistic update remains
   - If API call fails, the component reverts the optimistic update
   - Loading state prevents multiple clicks during API calls

5. **Batch Operations for Lists**:
   - List components use useBatchLikeStatus hook
   - Hook efficiently fetches like status for multiple items in parallel
   - Results are transformed into a lookup object for easy access

This frontend implementation provides a responsive user experience with immediate feedback while ensuring eventual consistency with the backend data. 

## Backend Flow

### 1. Controller
**File: `server/src/controllers/likeController.ts`**

```typescript
import { Request, Response } from 'express';  // Express types for request and response
import * as likeService from '../services/likeService';  // Import service functions

/**
 * Create a new like
 */
export const createLike = async (req: Request, res: Response) => {
  try {
    // Extract data from request body
    // req.body contains the JSON data sent in the POST request
    const { entity_type, entity_id } = req.body;  // Destructure to get specific fields
    
    // req.user is added by the authenticate middleware
    // It contains the authenticated user's information
    const userId = req.user.id;  // Get user ID from authenticated request
    
    // Validate input - ensure required fields are present
    // This prevents database errors from missing data
    if (!entity_type || !entity_id) {
      // Return early with 400 Bad Request status code
      // This follows REST conventions for invalid requests
      return res.status(400).json({ message: 'Missing required fields' });
    }
    
    // Check if like already exists to prevent duplicates
    // This is a business logic check before attempting database write
    const existingLike = await likeService.getLike(userId, entity_type, entity_id);
    if (existingLike) {
      // Return 409 Conflict for already existing resource
      // This is the appropriate HTTP status for duplicate creation attempts
      return res.status(409).json({ message: 'Already liked' });
    }
    
    // Create like in database by calling service function
    // The controller delegates database operations to the service layer
    const like = await likeService.createLike(userId, entity_type, entity_id);
    
    // Update like count on the entity
    // This is a separate operation to maintain denormalized count fields
    await likeService.incrementLikeCount(entity_type, entity_id);
    
    // Return success response with created like data
    // 201 Created is the appropriate status for resource creation
    return res.status(201).json(like);
  } catch (error) {
    // Log error for debugging and monitoring
    // This helps with troubleshooting production issues
    console.error('Error in createLike:', error);
    
    // Return generic error to client
    // Avoid exposing internal error details to clients
    return res.status(500).json({ message: 'Server error' });
  }
};

/**
 * Delete a like
 */
export const deleteLike = async (req: Request, res: Response) => {
  try {
    // Extract data from request body
    // For DELETE requests with body, data is in req.body
    const { entity_type, entity_id } = req.body;
    
    // Get user ID from authenticated request
    // This ensures users can only delete their own likes
    const userId = req.user.id;
    
    // Validate input - ensure required fields are present
    if (!entity_type || !entity_id) {
      // Return 400 Bad Request for invalid input
      return res.status(400).json({ message: 'Missing required fields' });
    }
    
    // Check if like exists before attempting to delete
    // This prevents errors from trying to delete non-existent resources
    const existingLike = await likeService.getLike(userId, entity_type, entity_id);
    if (!existingLike) {
      // Return 404 Not Found for non-existent resource
      // This follows REST conventions for resources that don't exist
      return res.status(404).json({ message: 'Like not found' });
    }
    
    // Delete like from database by calling service function
    // Pass the like ID to the service for precise deletion
    await likeService.deleteLike(existingLike.id);
    
    // Update like count on the entity
    // Maintain consistency of denormalized count fields
    await likeService.decrementLikeCount(entity_type, entity_id);
    
    // Return success response
    // 200 OK is appropriate for successful deletion
    return res.status(200).json({ message: 'Like removed' });
  } catch (error) {
    // Log error and return server error response
    console.error('Error in deleteLike:', error);
    return res.status(500).json({ message: 'Server error' });
  }
};

/**
 * Check if a user has liked an entity
 */
export const getLikeStatus = async (req: Request, res: Response) => {
  try {
    // Extract data from query parameters
    // For GET requests, data is in req.query (from URL parameters)
    // e.g., /likes/status?entity_type=post&entity_id=123
    const { entity_type, entity_id } = req.query;
    
    // Get user ID from authenticated request
    // This is needed to check if this specific user has liked the content
    const userId = req.user.id;
    
    // Validate input - ensure required fields are present
    if (!entity_type || !entity_id) {
      return res.status(400).json({ message: 'Missing required fields' });
    }
    
    // Check if like exists in database
    // Type assertions (as string) are needed because req.query values are considered
    // potentially undefined or string[] by TypeScript
    const existingLike = await likeService.getLike(
      userId, 
      entity_type as string,
      entity_id as string
    );
    
    // Return boolean indicating if like exists
    // The !! operator converts the object/null to a boolean
    // This simplifies the response for the frontend
    return res.json({ liked: !!existingLike });
  } catch (error) {
    // Log error and return server error response
    console.error('Error in getLikeStatus:', error);
    return res.status(500).json({ message: 'Server error' });
  }
};

/**
 * Get the like count for an entity
 */
export const getLikeCount = async (req: Request, res: Response) => {
  try {
    // Extract data from query parameters
    // This endpoint is public, so no user ID is needed
    const { entity_type, entity_id } = req.query;
    
    // Validate input - ensure required fields are present
    if (!entity_type || !entity_id) {
      return res.status(400).json({ message: 'Missing required fields' });
    }
    
    // Get like count from database
    // Call service function with type assertions for query parameters
    const count = await likeService.getLikeCount(
      entity_type as string,
      entity_id as string
    );
    
    // Return count in response
    // Wrap the count in an object for consistent JSON response format
    return res.json({ count });
  } catch (error) {
    // Log error and return server error response
    console.error('Error in getLikeCount:', error);
    return res.status(500).json({ message: 'Server error' });
  }
};
```

### 2. Service
**File: `server/src/services/likeService.ts`**

```typescript
import { prisma } from '../lib/prisma';  // Import Prisma client for database operations

/**
 * Create a new like
 */
export const createLike = async (userId: string, entityType: string, entityId: string) => {
  // Log operation for debugging and monitoring
  console.log(`[LIKE SERVICE] Creating like: user=${userId}, type=${entityType}, id=${entityId}`);
  
  // Create like record in database using Prisma's create method
  // This generates and executes an SQL INSERT statement behind the scenes
  // When this executes, Prisma:
  // 1. Prepares the data with user_id, entity_type, and entity_id
  // 2. Automatically generates a UUID for the id field (from @default(uuid()) in schema)
  // 3. Sets created_at to current timestamp (from @default(now()) in schema)
  // 4. Generates and executes an SQL INSERT statement
  // 5. Returns the complete record with all fields populated
  const like = await prisma.likes.create({  // This line initiates the database operation
    data: {                                 // The data object specifies what to insert
      user_id: userId,                      // User performing the like
      entity_type: entityType,              // Type of content being liked
      entity_id: entityId                   // ID of the content being liked 
    }
  });  // The await keyword pauses execution until the database operation completes
  
  // Log success
  console.log(`[LIKE SERVICE] Like created successfully: ${like.id}`);
  return like;  // Return created like object with generated ID and other fields
};

/**
 * Delete a like
 */
export const deleteLike = async (likeId: string) => {
  // Log operation for debugging and monitoring
  console.log(`[LIKE SERVICE] Deleting like: id=${likeId}`);
  
  // Delete like record from database using Prisma's delete method
  // When this executes, Prisma:
  // 1. Generates an SQL DELETE statement with a WHERE clause for the ID
  // 2. Executes the statement against the database
  // 3. Returns the deleted record (which was fetched before deletion)
  const deletedLike = await prisma.likes.delete({  // This initiates the database deletion
    where: { id: likeId }  // Specifies which record to delete by primary key
  });  // The await keyword pauses execution until deletion completes
  
  // Log success
  console.log(`[LIKE SERVICE] Like deleted successfully: ${likeId}`);
  return deletedLike;  // Return deleted like object for potential use by caller
};

/**
 * Get a like by user, entity type, and entity ID
 */
export const getLike = async (userId: string, entityType: string, entityId: string) => {
  // Log operation for debugging and monitoring
  console.log(`[LIKE SERVICE] Checking like status: user=${userId}, type=${entityType}, id=${entityId}`);
  
  // Find like in database using Prisma's findFirst method
  // When this executes, Prisma:
  // 1. Generates an SQL SELECT statement with multiple WHERE conditions
  // 2. Executes the query against the database
  // 3. Returns the first matching record or null if none found
  const like = await prisma.likes.findFirst({  // This initiates the database query
    where: {                                   // The where object defines search criteria
      user_id: userId,                         // Must match this user
      entity_type: entityType,                 // Must match this content type
      entity_id: entityId                      // Must match this content ID
    }
  });  // The await keyword pauses execution until query completes
  
  // Log result
  console.log(`[LIKE SERVICE] Like status: ${like ? 'Liked' : 'Not liked'}`);
  return like;  // Return like object or null if not found
};

/**
 * Get the like count for an entity
 */
export const getLikeCount = async (entityType: string, entityId: string) => {
  // Log operation for debugging and monitoring
  console.log(`[LIKE SERVICE] Getting like count: type=${entityType}, id=${entityId}`);
  
  // Count likes in database using Prisma's count method
  // When this executes, Prisma:
  // 1. Generates an SQL COUNT query with WHERE conditions
  // 2. Executes the query against the database
  // 3. Returns just the count as a number
  const count = await prisma.likes.count({  // This initiates the counting operation
    where: {                                // The where object defines which likes to count
      entity_type: entityType,              // Must match this content type
      entity_id: entityId                   // Must match this content ID
    }
  });  // The await keyword pauses execution until count completes
  
  // Log result
  console.log(`[LIKE SERVICE] Like count: ${count}`);
  return count;  // Return the count as a number
};

/**
 * Increment the like count on an entity
 */
export const incrementLikeCount = async (entityType: string, entityId: string) => {
  // Log operation for debugging and monitoring
  console.log(`[LIKE SERVICE] Incrementing like count: type=${entityType}, id=${entityId}`);
  
  let result;
  // Update like count on the entity based on entity type
  switch (entityType) {
    case 'post':
      // When this executes, Prisma:
      // 1. Generates an SQL UPDATE statement with atomic increment
      // 2. Executes the update against the database
      // 3. Returns the updated post record
      result = await prisma.posts.update({        // This initiates the update operation
        where: { id: entityId },                  // Specifies which post to update
        data: { likes: { increment: 1 } }         // Uses atomic increment for thread safety
      });  // The await keyword pauses execution until update completes
      console.log(`[LIKE SERVICE] Post like count updated: ${result.likes}`);
      break;
    case 'article':
      // Similar process for articles table
      result = await prisma.articles.update({     // This initiates the update operation
        where: { id: entityId },                  // Specifies which article to update
        data: { likes: { increment: 1 } }         // Uses atomic increment for thread safety
      });
      console.log(`[LIKE SERVICE] Article like count updated: ${result.likes}`);
      break;
    case 'project':
      // Similar process for projects table, but different field name
      result = await prisma.projects.update({     // This initiates the update operation
        where: { id: entityId },                  // Specifies which project to update
        data: { project_followers: { increment: 1 } }  // Uses atomic increment for thread safety
      });
      console.log(`[LIKE SERVICE] Project followers count updated: ${result.project_followers}`);
      break;
    case 'comment':
      // Similar process for comments table, but different field name
      result = await prisma.comments.update({     // This initiates the update operation
        where: { id: entityId },                  // Specifies which comment to update
        data: { likes_count: { increment: 1 } }   // Uses atomic increment for thread safety
      });
      console.log(`[LIKE SERVICE] Comment like count updated: ${result.likes_count}`);
      break;
    default:
      // Handle unknown entity types
      console.log(`[LIKE SERVICE] Unknown entity type: ${entityType}, no count updated`);
      return null;
  }
  
  return result;  // Return updated entity with new count
};

/**
 * Decrement the like count on an entity
 */
export const decrementLikeCount = async (entityType: string, entityId: string) => {
  // Log operation for debugging and monitoring
  console.log(`[LIKE SERVICE] Decrementing like count: type=${entityType}, id=${entityId}`);
  
  let result;
  // Update like count on the entity based on entity type
  switch (entityType) {
    case 'post':
      // When this executes, Prisma:
      // 1. Generates an SQL UPDATE statement with atomic decrement
      // 2. Executes the update against the database
      // 3. Returns the updated post record
      result = await prisma.posts.update({        // This initiates the update operation
        where: { id: entityId },                  // Specifies which post to update
        data: { likes: { decrement: 1 } }         // Uses atomic decrement for thread safety
      });  // The await keyword pauses execution until update completes
      console.log(`[LIKE SERVICE] Post like count updated: ${result.likes}`);
      break;
    case 'article':
      // Similar process for articles table
      result = await prisma.articles.update({     // This initiates the update operation
        where: { id: entityId },                  // Specifies which article to update
        data: { likes: { decrement: 1 } }         // Uses atomic decrement for thread safety
      });
      console.log(`[LIKE SERVICE] Article like count updated: ${result.likes}`);
      break;
    case 'project':
      // Similar process for projects table, but different field name
      result = await prisma.projects.update({     // This initiates the update operation
        where: { id: entityId },                  // Specifies which project to update
        data: { project_followers: { decrement: 1 } }  // Uses atomic decrement for thread safety
      });
      console.log(`[LIKE SERVICE] Project followers count updated: ${result.project_followers}`);
      break;
    case 'comment':
      // Similar process for comments table, but different field name
      result = await prisma.comments.update({     // This initiates the update operation
        where: { id: entityId },                  // Specifies which comment to update
        data: { likes_count: { decrement: 1 } }   // Uses atomic decrement for thread safety
      });
      console.log(`[LIKE SERVICE] Comment like count updated: ${result.likes_count}`);
      break;
    default:
      // Handle unknown entity types
      console.log(`[LIKE SERVICE] Unknown entity type: ${entityType}, no count updated`);
      return null;
  }
  
  return result;  // Return updated entity with new count
};
```

### 3. Routes
**File: `server/src/routes/likeRoutes.ts`**

```typescript
import { Router } from 'express';  // Express router for defining routes
import * as likeController from '../controllers/likeController';  // Import controller functions
import { authenticate } from '../middlewares/auth';  // Import auth middleware

// Create a new router instance
const router = Router();

// Protected routes (require authentication)
router.post('/', authenticate, likeController.createLike);  // Create like endpoint
router.delete('/', authenticate, likeController.deleteLike);  // Delete like endpoint
router.get('/status', authenticate, likeController.getLikeStatus);  // Check like status endpoint

// Public routes (no authentication required)
router.get('/count', likeController.getLikeCount);  // Get like count endpoint

export default router;  // Export router for use in main app
```

### 4. Main Router
**File: `server/src/routes/index.ts`**

```typescript
import likeRoutes from './likeRoutes';  // Import like routes

// Add this line where you define your routes
router.use('/likes', likeRoutes);  // Mount like routes under /likes path
```

### 5. Database Schema
**File: `server/prisma/schema.prisma`**

```prisma
model likes {
  id          String   @id @default(uuid())  // Unique identifier with auto-generated UUID
  user_id     String   // ID of user who performed the like
  entity_type String   // Type of content being liked (post, article, etc.)
  entity_id   String   // ID of the content being liked

  created_at  DateTime @default(now())  // Timestamp when like was created

  // Relation to users table
  users       users?   @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@map("likes")  // Maps to "likes" table in database
}
```

## Complete Request Flow

### Like Creation Flow

1. **Frontend Initiates Request**:
   - User clicks like button on a post
   - LikeButton component calls `likeEntity("post", "123")`
   - API service makes POST request to `/likes` with entity data

2. **Backend Route Handling**:
   - Request hits `router.post('/', authenticate, likeController.createLike)`
   - `authenticate` middleware verifies user is logged in and adds user to request
   - Request is passed to `createLike` controller function

3. **Controller Processing**:
   - Controller extracts data from request
   - Validates required fields are present
   - Checks if like already exists to prevent duplicates
   - Calls service functions to create like and update count

4. **Service Database Operations**:
   - `createLike` service creates record in likes table
   - `incrementLikeCount` service updates count on the entity
   - Both operations log details for monitoring

5. **Response Flow**:
   - Service returns created like to controller
   - Controller sends JSON response with 201 status
   - Frontend receives response
   - If successful, optimistic UI update remains
   - If error occurs, UI reverts to previous state

### Like Status Check Flow

1. **Frontend Initiates Request**:
   - Component mounts and needs to know if user has liked content
   - API service makes GET request to `/likes/status?entity_type=post&entity_id=123`

2. **Backend Route Handling**:
   - Request hits `router.get('/status', authenticate, likeController.getLikeStatus)`
   - `authenticate` middleware verifies user and adds user to request
   - Request is passed to `getLikeStatus` controller function

3. **Controller Processing**:
   - Controller extracts entity data from query parameters
   - Validates required fields are present
   - Calls service function to check if like exists

4. **Service Database Operation**:
   - `getLike` service queries database for matching like
   - Returns like object or null

5. **Response Flow**:
   - Controller converts result to boolean and sends JSON response
   - Frontend receives response and updates UI accordingly

This backend implementation works seamlessly with the frontend to provide a complete likes functionality across different content types, with proper authentication, validation, and error handling at each step. 